/***************************************************************************************************    
工程名称：  IIC
功能描述：  实现MCU与MC523的iic通信功能
硬件连接：  
Author  ：  dzg  
***************************************************************************************************/
#include "msp430x24x.h"
//#include "io430.h"
//#include "nbc430.h"
//#include "io430x24x.h"
#define uchar unsigned char
#define uint  unsigned int

#define IO_SELECT 0           //0 选择iic管脚为P60为SDA,P61为SCL; 1 选择iic管脚为P36为SDA,P37为SCL

//#define sda  P6OUT          //数据线P60
//#define scl  P6OUT          //时钟线P61
//#define Dataport P6         //数据口定义

//***********************************************************************************
//延时
//***********************************************************************************
void delay(uint time)
{
	uint i,j;
	for(i = 0;i < time; i++)
	{
	  // for(j = 0;j <30; j++);for(j = 0;j <30; j++);for(j = 0;j <30; j++);
          for(j = 0;j <200; j++);for(j = 0;j <200; j++);
    	}
}
//***********************************************************************************
//IO初始化操作
//***********************************************************************************
void IO_init(void)
{
#if IO_SELECT
	P3DIR |=0xC0;		    //设置P36,P37为输出
	P3OUT |=0xC0;               //设置P36,P37初始化为高电平
	//P3REN |= BIT6+BIT7;         // ENABLE PULL RESISTOR
	P3DIR|=BIT6;P3DIR|=BIT7;    //设置P36与P37输出
        P3OUT |=(BIT6+BIT7);        //设置P36与P37初始化为高电平
#else        
        P6DIR |=0x03;		    //设置P60,P61为输出
	P6OUT |=0x03;               //设置P60,P61初始化为高电平
        //P6REN |= BIT6+BIT7;       // ENABLE PULL RESISTOR      实际通过外部上拉  
	P6DIR|=BIT0;
        P6DIR|=BIT1;                //设置P60与P61输出
        P6OUT |=(BIT0+BIT1);        //设置P60与P61初始化为高电平
#endif 
}
//**************************************************************************************************
//启动(SCL为高，SDA由高变为低是一个开始条件)
//**************************************************************************************************
void start()  
{	
#if IO_SELECT
	P3OUT |=BIT6;  //sda;         //数据线置高,P36             
	delay(1);
	P3OUT |=BIT7;  //scl;         //时钟线置高 P37
	delay(1);
	P3OUT &=~BIT6;               //数据线置低,由高变低
	delay(1);
	P3OUT &=~BIT7;               //时钟线置低,准备发送或接收数据,总线进入忙状态(I2C总线在空闲状态时，SDA与SCL均被置高)
	delay(1);
#else       
        P6OUT |=BIT0;           //数据线置高,P60           
	delay(1);
	P6OUT |=BIT1;           //时钟线置高
	delay(1);
	P6OUT &=~BIT0;          //数据线置低,由高变低
	delay(1);
	P6OUT &=~BIT1;          //时钟线置低,准备发送或接收数据,总线进入忙状态(I2C总线在空闲状态时，SDA与SCL均被置高)
	delay(1);
#endif
}
//**************************************************************************************************
//停止（SCL为高，SDA由低变为高是一个结束条件）
//**************************************************************************************************
void stop()   
{
 #if IO_SELECT
	P3OUT &=~BIT6;              //数据线置低
	delay(1);                   //延时
	P3OUT |=BIT7;               //时钟线置高
	delay(1);                   //延时
	P3OUT |=BIT6;               //数据线置高，由低变高
	delay(1);                   //延时
 #else       
        P6OUT &=~BIT0;              //数据线置低
	delay(1);                   //延时
	P6OUT |=BIT1;               //时钟线置高
	delay(1);                   //延时
	P6OUT |=BIT0;               //数据线置高，由低变高
	delay(1);                   //延时
#endif
}
//**************************************************************************************************
//检测应答(所有的地址和数据字都是以8bit,在第9个时钟周期，从器件发出"0"信号来作为收到一个字的应答信号)
//**************************************************************************************************
void checkACK()                  //主器件检测从器件是否返回应答
{
  
#if IO_SELECT
	P3DIR&=(~BIT6);                 //设置查忙位为输入 数据线
        P3OUT |=BIT7;                   //时钟线置高
	delay(1);                       //延时
	while((P3IN&0x40)==0x40);       //等待第9个时钟周期器件发出的响应信号"0"
        
	P3DIR |=BIT6;                   //设置查忙位为输出
        P3OUT &=~BIT7;                  //时钟线置低
	delay(1);                       //延时
#else 

        P6DIR&=(~BIT0);                 //设置查忙位为输入 数据线
        P6OUT |=BIT1;                   //时钟线置高
	delay(1);                       //延时
	while((P6IN&0x01)==0x01);       //等待第9个时钟周期器件发出的响应信号"0"
        
        P6OUT &=~BIT1;                  //时钟线置低
	P6DIR |=BIT0;                   //设置查忙位为输出
	delay(1);                       //延时
#endif
}
//**************************************************************************************************
//发送应答(发送方为主器件，接收方为从器件，控制器作为从器件接收完1数据时，发送应答信号
//**************************************************************************************************
void sendACK(uchar ACK)                   
{
#if IO_SELECT 
  
        if(ACK)P3OUT |=BIT6;         //如果i位为1则发送1,即发送"非应答信号"
        else P3OUT &=~BIT6;          //如果i位为0则发送0,即发送"应答信号"	
        delay(1);                    //延时
        P3OUT |=BIT7;                //时钟线置高,给一个脉冲
	delay(1);                    //延时
	P3OUT &=~BIT7;               //时钟线置低
	delay(1);                    //延时
#else        
        if(ACK)P6OUT |=BIT0;         //如果i位为1则发送1,即发送"非应答信号"
        else P6OUT &=~BIT0;          //如果i位为0则发送0,即发送"应答信号"	
        delay(1);                    //延时
        P6OUT |=BIT1;                //时钟线置高,给一个脉冲
	delay(1);                    //延时
	P6OUT &=~BIT1;               //时钟线置低
	delay(1);                    //延时
#endif
}
//**************************************************************************************************
//写一字节
//**************************************************************************************************
void send_byte(uchar date)   //写一个8位字
{
#if IO_SELECT  
	uchar i,temp;                //定义局部变量
	temp=date;                  //待发8位数据赋予temp
	for(i=0;i<8;i++)            //循环8次，每次写入1位，从最高位开始发送
	{
          if(temp&0x80)P3OUT |=BIT6; //如果temp最高位为1则发送1
                  else P3OUT &=~BIT6;//如果temp最高位为0则发送0
          delay(1);
	  P3OUT |=BIT7;             //给一个脉冲，发送sda当前这位数据
	  delay(1);                 //延时,需大于4us(参考数据手册时序图) 
	  P3OUT &=~BIT7;             //时钟线置低,准备下一脉冲
	  delay(1);          //延时,需大于4.7us(参考数据手册时序图) 
	  temp=temp<<1;      //左移1位，准备好下1位待发送的数据
	}
         delay(1);          //延时,需大于4.7us(参考数据手册时序图) 
	 checkACK();         //查询是否返回应答信号
#else       
	uchar i,temp;        //定义局部变量
	temp=date;           //待发8位数据赋予temp
	for(i=0;i<8;i++)     //循环8次，每次写入1位，从最高位开始发送
	{
          if(temp&0x80)P6OUT |=BIT0;//如果temp最高位为1则发送1
                  else P6OUT &=~BIT0;//如果temp最高位为0则发送0
          delay(1);
	  P6OUT |=BIT1;             //给一个脉冲，发送sda当前这位数据
	  delay(1);                 //延时,需大于4us(参考数据手册时序图) 
	  P6OUT &=~BIT1;            //时钟线置低,准备下一脉冲
	  delay(1);                 //延时,需大于4.7us(参考数据手册时序图) 
	  temp=temp<<1;             //左移1位，准备好下1位待发送的数据
	}
	 checkACK();                //查询是否返回应答信号
#endif       
}
//**************************************************************************************************
//读一字节
//**************************************************************************************************
uchar receive_byte()               //读一个8位字
{
#if IO_SELECT   
        uchar i,temp,data_sda;     //定义局部变量
	P3DIR&=(~BIT6);            //设置数据线为输入
	delay(1);                 //延时
	for(i=0;i<8;i++)           //循环8次，每次读取1位，从最高位开始接收
	{
		P3OUT |=BIT7;             //给一脉冲，准备发送1位数据            
		delay(1);          //延时,需大于4us(参考数据手册时序图) 
		temp=temp<<1;      //结果左移1位
                data_sda=P3IN&0x40;//读取1位数据
                if(data_sda!=0)    //判断数据是0还是1
                temp=temp|0x01;    //读取1位数据,放在temp最低位
		P3OUT &=~BIT7;             //准备给下1个脉冲
	        delay(1);          //延时,需大于4.7us(参考数据手册时序图) 
	}
        P3DIR|=BIT6;               //设置数据线为输出
	return temp;               //返回读取的8位数据
 #else       
        uchar i,temp,data_sda;     //定义局部变量
	P6DIR&=(~BIT0);            //设置数据线为输入
	 delay(1);                 //延时
	for(i=0;i<8;i++)           //循环8次，每次读取1位，从最高位开始接收
	{
		P6OUT |=BIT1;             //给一脉冲，准备发送1位数据            
		delay(1);          //延时,需大于4us(参考数据手册时序图) 
		temp=temp<<1;      //结果左移1位
                data_sda=P6IN&0x01;//读取1位数据
                if(data_sda!=0)    //判断数据是0还是1
                temp=temp|0x01;    //读取1位数据,放在temp最低位
		P6OUT &=~BIT1;     //准备给下1个脉冲
	        delay(1);          //延时,需大于4.7us(参考数据手册时序图) 
	}
        P6DIR|=BIT0;               //设置数据线为输出
	return temp;               //返回读取的8位数据
#endif      
}


//**************************************************************************************************
//向I2C器件的某字地址写一字节数据
//**************************************************************************************************
void write_word(uchar device_add,uchar word_add,uchar date)  //写进去一个存储数据
{
	start();                  //启动
	send_byte(device_add<<1);    //选择从器件地址,RW位为0，即选择写命令
	send_byte(word_add);      //写字地址
	send_byte(date);          //写数据
	stop();                   //停止        
}
//**************************************************************************************************
//向I2C器件的某字地址读一字节数据
//**************************************************************************************************
uchar read_word(uchar device_add,uchar word_add)   //读出一个存储的数据
{
	uchar date;
	start();                 //启动
	send_byte(device_add<<1);   //选择从器件地址,RW位为0，即选择写命令
        //send_byte(device_add);   //选择从器件地址,RW位为0，即选择写命令
	send_byte(word_add);     //写字地址
        
        start();                 //启动
	send_byte((device_add<<1)+1); //选择从器件地址,RW位为1，即选择读命令
        //send_byte(device_add+1); //选择从器件地址,RW位为1，即选择读命令
	date=receive_byte();     //读数据
        sendACK(1);              //发送非应答信号
	stop();                  //停止
	return date;             //返回读取结果数据
}
//**************************************************************************************************
//测试函数
//**************************************************************************************************
uchar array[100]={0};                 //定义中间变量
void iic_test(void)
{	
  uchar temp=0xaa,temp2=0,temp3=3,i=0;
  
   //WDTCTL = WDTPW + WDTHOLD;     //禁止看门狗复位
   //IO_init();//IO初始化
   for(i=0;i<100;i++)
   {
       temp=read_word(0x0a,0x2c);       //从I2C器件a0的第0个地址读出数据赋予temp
       array[i]=temp;
       temp3+=1;
       write_word(0x0A,0x2c,temp3);    //向I2C器件a0的第0个地址写temp+1
       
       //delay(100);                   //延时等待器件完成写操作 
   }
   
   while(1)                      //死循环
    {     
          temp=read_word(0x0A,0);//从第0个地址读出一个数据 	
	  delay(300); 	         //延时等待
          //Dataport =~temp;       //送数据到LED显示  
    }
}